{
  "name": "StarSmasher",
  "tagline": "A Smoothed Particle Hydrodynamics code for smashing stars (and planets)",
  "body": "Please contact Jamie Lombardi (jamie.lombardi@allegheny.edu) with any\r\nquestions.\r\n\r\nOBTAINING AND COMPILING\r\n-----------------------\r\n\r\nGet the code from the repository at https://github.com/jalombar/starsmasher/.\r\n\r\nThe main directory contains at least three subdirectories:\r\n\r\nexample_input:          contains example input files for various cases\r\nmisc:\t\t\tmiscellaneous files such as assorted makefiles and the StarCrash manual\r\nparallel_bleeding_edge: latest version of code (this is probably what you want)\r\n\r\nFor runs on a gpu-enabled cluster, the directory you care about is\r\nparallel_bleeding_edge.  Let's try to compile the code in there:\r\n\r\n   cd parallel_bleeding_edge/src/SPHgrav_lib\r\n\r\nThe SPHgrav_lib subdirectory contains code written by Evghenii Gaburov\r\n(and somewhat modified by Jamie Lombardi and Sam Knarr) for\r\ncalculating softened gravitational forces and potentials on NVIDIA\r\nGPUs.  If you are running on something other than keeneland, you will\r\nneed to customize the Makefile for your system: any path that contains\r\n\"cuda\" or \"CUDA\" probably needs to be changed.  To make the library,\r\nsimply issue the command\r\n\r\n   make\r\n\r\n(The final thing that make does is \"./makelib.sh\" which is what will make the\r\nlibrary.)  If it doesn't work, and you want to have a fresh start,\r\nfirst use \"make clean\".  If all goes well the library\r\nlibGPUsph_gatherscatter.a will be generated.\r\n\r\nThe SPH source code is in the .. directory.  This is a parallel code.\r\nExecute\r\n\r\n   cd ..\r\n\r\nso that you're in the src subdirectory.  Then\r\n\r\n   cp makefile.keeneland makefile\r\n\r\nTo compile, type\r\n\r\n   make\r\n\r\nYou will likely need to customize the makefile for your computer.  For\r\nexample, you may need to change the compiler or update paths to point\r\nto the appropriate locations.  The executable name will end with _sph\r\nand will depend on the name of the directory that src appears within.\r\nThe executable will automatically be moved up a level in the directory\r\nstructure (that is, to the \"..\"  directory).  You probably want to\r\nremove the executable for now so that you don't later copy it to other\r\nplaces where you don't want it:\r\n\r\n   cd ..\r\n   rm *_sph\r\n\r\nAlthough this Starsmasher code is not well documented, there is\r\ndocumentation for Starcrash, which is a previous version of this code\r\n(see http://ciera.northwestern.edu/StarCrash/).  Although Starcrash is\r\nnot the same as Starsmasher, the variable names, input files, output\r\nfiles, and parallelization strategy is very similar.  The Starcrash\r\ndocumentation is available as the file usersmanual.pdf in the\r\nmisc subdirectory and may be somewhat helpful to peruse.  You will\r\nbe most interested in pages 31 - 36, which talks about input and\r\noutput.  Remember, however, that this Starsmasher SPH code is different in\r\nmany ways.  The algorithms of Starsmasher are mostly described in\r\nhttp://adsabs.harvard.edu/abs/2010MNRAS.402..105G.  The AV scheme is\r\ndescribed in Ponce et al. (2011).\r\n\r\n\r\nEXAMPLE RUNS\r\n------------\r\n\r\nThere are two steps to modelling a collision or fly-by of two stars.\r\nFirst, you have to model the individual star: a relaxation run.\r\nSecond, you simulate the interaction: a dynamical calculation.\r\n\r\nStep 1: Relaxation runs\r\n-----------------------\r\n\r\nStep 1(a): Relaxing a n=1.5 polytrope\r\n-------------------------------------\r\n\r\nLet's have you do your own simulation for practice.  We'll use N=1000,\r\nso that the code runs very quickly.  Let's try an equation of state\r\ngoverned by the adiabatic index gamma=5/3, and a structure specified\r\nby the polytropic index n=1.5.\r\n\r\nFirst, get the directories ready:\r\n   cd ..  ####   or maybe \"cd ~/starsmasher\" depending on where your installation is\r\n   cp -r parallel_bleeding_edge GAM1.667_n1.5\r\n   cd GAM1.667_n1.5\r\n   cp ../example_input/relaxation_preMS/sph.in* .\r\nThe file sph.init controls what type of calculation we will do.\r\nConfirm that the three letter code word inside sph.init is '1es' for\r\nthis polytrope relaxation (and update the text if necessary):\r\n   emacs -nw sph.init\r\nYou should look at sph.input:\r\n   emacs -nw sph.input #### [or use some other editor]\r\nChange line 4 of sph.input to be N=2000 and save the file.  There are\r\nseveral other variables that could be changed, but the defaults should\r\nbe fine for now.  See the Starcrash documentation for an explanation\r\nof what some of the other variables are.\r\n\r\nNow let's compile the source code:\r\n   cd src\r\n   cat sphu.h\r\nConfirm that the last line sets the adiabatic index GAM=5.d0/3.d0.\r\n   emacs -nw initialize_polyes.f\r\nConfirm that the lines right after the declaration section will set the\r\npolytropic constant npoly to be 1.5.\r\nThe radius and mass are set on near here.  These values are\r\nin physical units of runit and munit, which are set at the end of sph.input\r\nand are typically the radius and mass of the sun in cgs units.  Save initialize_polyes.f\r\nwhen done and then try to compile:\r\n   make\r\nOnce everything goes well with the\r\ncompilation, the last line you should see is \"mv GAM1.667_n1.5_sph\r\n..\".  Get positioned to run the code:\r\n   cd ..\r\nand get a good batch script if you don't have one\r\n   cp ../sph.pbs.kfs sph.pbs\r\nThe default sph.pbs file asks for only 1 minute, so you'll need to\r\nchange that for a real run.  To run the code,\r\n   qsub -q debug sph.pbs ### or, for long jobs, \"qsub sph.pbs\"\r\nThis creates, among other things, a file log0.sph that collects\r\nascii tex about the run.\r\n\r\nStep 1(b): Relaxing a TWIN model\r\n--------------------------------\r\n\r\nGet the directories ready:\r\n   cd ~/starsmasher   ### or cd to wherever your main installation is\r\n   cp -r parallel_bleeding_edge TWIN\r\n   cd TWIN\r\n   cp ../example_input/relaxation_TWIN_model/* .\r\n\r\nTo relax a TWIN model instead, the three letter code word in sph.init\r\nshould be 'erg'.  The SPH code will look for a model named\r\n'eg.last1.muse_s2mm'.  You can create a symbolic link from an\r\nappropriate output file of TWIN if you like (e.g.,\r\n\"cp -s m_8_t_5.7.last1.muse_s2mm eg.last1.muse_s2mm\").  The file\r\nm_8_t_5.7.last1.muse_s2mm is the default in\r\nexample_input/relaxation_TWIN_model.  It represents an 8M_sun MS\r\nstar at t=5.7Myr.\r\n\r\nThe sph.input file, also available within\r\nexample_input/relaxation_TWIN_model/, should be similar to the\r\nsph.input file used above for the polytrope (probably just change N\r\nand nothing else unless necessary).  The file on the svn site does\r\nhave TRELOFF to 200 in this case, to make sure there was enough time\r\nfor oscillations to die off, and TF is 300 so the star could be\r\nmonitored for 100 time units after the relaxation was turned off.\r\n\r\nRun the code like before:\r\n   cd src\r\n   make\r\n   cd ..\r\n   cp ../sph.pbs.kfs ./sph.pbs\r\n   qsub -q debug sph.pbs\r\n\r\nStep 2: Dynamical calculation\r\n-----------------------------\r\n\r\nIf the model from the relaxation run at t=TRELOFF looks good, then you\r\ncan use that to start a dynamical calculation.  Start by get the\r\ndirectories ready:\r\n  cd ~/starsmasher   ### or cd to wherever your main installation is\r\n  cp -r parallel_bleeding_edge/ collision_rp3.9_a119\r\n  cd collision_rp3.9_a119\r\n  cp ../example_input/collision/sph.in* .\r\n  emacs -nw sph.init\r\nMake sure the second line of sph.init says INAME='hyp'.\r\n\r\nThe new sph.input file is set up for doing dynamical calculations.\r\nTake a look at it:\r\n  emacs -nw sph.input\r\nWhile you're in the file, check that DTOUT=1 on line 3, which\r\nmeans that an out*.sph file will be dumped every 1 time unit.  Also,\r\non line 16 or so, make BIMPACT=3.9d0, which means the periastron separation\r\nof the initial orbit is 3.9 stellar radii.\r\n\r\nIn sph.input you can use any of the following pairs of data to initialize a collision in hyperbolic.f: (e0,vinf2), (e0,bimpact), (semimajoraxis,bimpact), (semimajoraxis,e0), (bimpact,vinf2).  Here e0 is the eccentricity of the initial orbit, and bimpact is the periastron separation (not really the impact parameter).  For example, sph.input could contain\r\n\r\n BIMPACT=4.d0,\r\n semimajoraxis=118.57d0,\r\n\r\nand e0 and vinf2 could be unspecified.  Or you could specify BIMPACT and e0, and the same code works, etc.  The code in initialize_hyperbolic.f figures out what it needs to solve for.\r\n\r\nWhether the encounter is hyperbolic, parabolic, or elliptical is\r\ncontrolled by the velocity at infinity squared, vinf2, or the semimajoraxis a.\r\nThe value of vinf2 is negative for elliptical encounters, zero for\r\nparabolic encounters, and positive for hyperbolic encounters.  Note\r\nthat the orbital energy G*M*mu/(-2a) just equals mu*vinf2/2.\r\nTherefore, there is a simple relation between the semimahor axis a and\r\nvinf2, namely.  a=-G*M/vinf2, where M is the total mass of the two\r\nstars.  For example, if you are colliding a 0.3 Msun and 8Msun star\r\nand if vinf2=-0.07, then the semimajor axis a=(0.3+8)/0.07=118.57,\r\nwhere I assume the units chosen are the usual G=Msun=Rsun=1.\r\n\r\nNote that ngravprocs=-6 and ppn=16... this means there are\r\nabs(ngravprocs)=6 GPU units per 16 CPU cores, as on one node of the\r\nsupercomputer forge.  You should change these values to be appropriate\r\nfor your machine.  For example, on Keeneland KFS, there are 3 gpus and\r\n12 cores per node.\r\n\r\nLet's get the star models:\r\n  cp ../TWIN/*/out0200.sph ./sph.start1u\r\n  cp ../GAM1.667_n1.5/*/out0100.sph ./sph.start2u\r\nwhere we assume the 8 solar mass ZAMS star was relaxed in the directory ../TWIN/.\r\nNow let's compile the code:\r\n  cd src\r\n  make\r\nTo run the code, get to the same directory as the executable:\r\n  cd ..\r\nthen\r\n  cp ../sph.pbs.kfs ./sph.pbs\r\n  qsub -q debug sph.pbs\r\n\r\nRESTARTING RUNS\r\n---------------\r\n\r\nEvery few iterations, a restartrad.sph file is dumped (overwriting any\r\npreviously existing restartrad.sph file).  If a restartrad.sph file\r\nexists in the directory when a new run is launched, then the code will\r\nautomatically use that file to initiate the calculation.  This is\r\nuseful for restarting in the middle of a long simulation.  You can\r\nalso restart from any out*.sph file simply by renaming it to\r\nrestartrad.sph.\r\n\r\nDATA VISUALIZATION\r\n------------------\r\n\r\nI recommend Price's SPLASH software.  It will need to be customized to\r\nread in our output file type.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}